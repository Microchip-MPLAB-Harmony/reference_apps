/*******************************************************************************
  USB I2C click routine example source file

  Company
    Microchip Technology Inc.

  File Name
    usb_i2c_example.c

  Summary
    USB I2C click routine example implementation file.

  Description
    This file defines the usage of the USB I2C click routine APIs.

  Remarks:
    None.

 *******************************************************************************/

// DOM-IGNORE-BEGIN
/*
    (c) 2021 Microchip Technology Inc. and its subsidiaries. You may use this
    software and any derivatives exclusively with Microchip products.

    THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
    EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY IMPLIED
    WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A
    PARTICULAR PURPOSE, OR ITS INTERACTION WITH MICROCHIP PRODUCTS, COMBINATION
    WITH ANY OTHER PRODUCTS, OR USE IN ANY APPLICATION.

    IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
    INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
    WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS
    BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE
    FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN
    ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY,
    THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS SOFTWARE.

    MICROCHIP PROVIDES THIS SOFTWARE CONDITIONALLY UPON YOUR ACCEPTANCE OF THESE
    TERMS.
*/
// DOM-IGNORE-END

/**
  Section: Included Files
 */

#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include "definitions.h"                // SYS function prototypes
#include "usb_i2c_example.h"
#include "usb_i2c.h"
#include "click_routines\click_interface.h"

#define USB_I2C_EMULATED_EEPROM_START_ADDR             0x00
#define USB_I2C_EMULATED_EEPROM_PAGE_SIZE_BYTES        256
#define USB_I2C_EMULATED_EEPROM_PAGE_SIZE_MASK         0xFF
#define USB_I2C_EMULATED_EEPROM_SIZE_BYTES             512

uint8_t USB_I2C_EEPROM_EmulationBuffer[USB_I2C_EMULATED_EEPROM_SIZE_BYTES];

typedef struct
{
    /* writeAddrPtr - write address */
    uint16_t                    writeAddrPtr;
    /* readAddrPtr - read address */
    uint16_t                    readAddrPtr;
    /* addrIndex - used to copy 2 bytes of emulated EEPROM memory address */
    uint8_t                     addrIndex;
    /* wrBuffer - holds the incoming data from the I2C master */
    uint8_t                     wrBuffer[USB_I2C_EMULATED_EEPROM_PAGE_SIZE_BYTES];
    /* wrBufferIndex - Index into the wrBuffer[] */
    uint16_t                    wrBufferIndex;
    /* wrAddr - indicates the starting address of the emulated EEPROM memory to write to */
    volatile uint16_t           wrAddr;
    /* nWrBytes - indicates the number of bytes to write to emulated EEPROM buffer */
    volatile uint16_t           nWrBytes;
    /* internalWriteInProgress - indicates that emulated EEPROM is busy with internal writes */
    bool                        internalWriteInProgress;
}USB_I2C_EMULATED_EEPROM_DATA;

USB_I2C_EMULATED_EEPROM_DATA emulated_EEPROM;

uint8_t USB_I2C_EEPROM_EmulationBuffer[USB_I2C_EMULATED_EEPROM_SIZE_BYTES] =
{
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
    0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
    0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
    0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,

    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
    0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
    0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
    0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
    0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
    0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
    0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
    0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
    0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
    0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
    0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
    0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
    0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
    0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
    0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
    0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff
};

/* usbI2cCommand - used to identify the sent Master command */
volatile USB_I2C_CMD usbI2cCommand;

USB_I2C_CMD USB_I2C_GetCommand(void)
{
    return usbI2cCommand;
}

bool USB_I2C_EEPROM_Event_Manager ( USB_I2C_SLAVE_TRANSFER_EVENT event, uintptr_t contextHandle )
{
    bool isSuccess = true;

    switch(event)
    {
        case USB_I2C_SLAVE_TRANSFER_EVENT_ADDR_MATCH:
            if ((USB_I2C_TransferDirGet() == USB_I2C_SLAVE_TRANSFER_DIR_WRITE) && (emulated_EEPROM.internalWriteInProgress == true))
            {
                /* emulated  EEPROM is busy. Send NAK */
                isSuccess = false;
            }
            else
            {
                /* Reset the indexes */
                emulated_EEPROM.addrIndex = 0;
                emulated_EEPROM.wrBufferIndex = 0;
            }
            break;

        case USB_I2C_SLAVE_TRANSFER_EVENT_RX_READY:
            if (emulated_EEPROM.addrIndex < 2)
            {
                ((uint8_t*)&emulated_EEPROM.writeAddrPtr)[emulated_EEPROM.addrIndex++] = USB_I2C_MasterRead();
            }
            else
            {
                emulated_EEPROM.wrBuffer[(emulated_EEPROM.wrBufferIndex & USB_I2C_EMULATED_EEPROM_PAGE_SIZE_MASK)] = USB_I2C_MasterRead();
                emulated_EEPROM.wrBufferIndex++;
            }
            break;

        case USB_I2C_SLAVE_TRANSFER_EVENT_TX_READY:
            /* Provide the emulated EEPROM data requested by the I2C Master */
            USB_I2C_MasterWrite(USB_I2C_EEPROM_EmulationBuffer[emulated_EEPROM.readAddrPtr++]);
            if (emulated_EEPROM.readAddrPtr >= USB_I2C_EMULATED_EEPROM_SIZE_BYTES)
            {
                emulated_EEPROM.readAddrPtr = USB_I2C_EMULATED_EEPROM_START_ADDR;
            }
            break;

        case USB_I2C_SLAVE_TRANSFER_EVENT_STOP_BIT_RECEIVED:
            if (emulated_EEPROM.wrBufferIndex > 0)
            {
                if (emulated_EEPROM.wrBufferIndex > USB_I2C_EMULATED_EEPROM_PAGE_SIZE_BYTES)
                {
                    emulated_EEPROM.wrBufferIndex = USB_I2C_EMULATED_EEPROM_PAGE_SIZE_BYTES;
                }
                emulated_EEPROM.wrAddr = emulated_EEPROM.writeAddrPtr;
                emulated_EEPROM.nWrBytes = emulated_EEPROM.wrBufferIndex;

                /* Update the current address pointer to allow for sequential write */
                emulated_EEPROM.writeAddrPtr += emulated_EEPROM.wrBufferIndex;

                /* Reset the indexes */
                emulated_EEPROM.addrIndex = 0;
                emulated_EEPROM.wrBufferIndex = 0;

                /* Set busy flag to send NAK for any write requests */
                emulated_EEPROM.internalWriteInProgress = true;
                usbI2cCommand = USB_I2C_CMD_WRITE;
            }
            /* Reset the read address back to beginning of the emulated EEPROM */
            emulated_EEPROM.readAddrPtr = 0;
            break;
        default:
            break;
    }
    return isSuccess;
}

void USB_I2C_Example(void)
{
    usbI2cCommand = USB_I2C_CMD_IDLE;

    USB_I2C_CallbackRegister(&USB_I2C_EEPROM_Event_Manager, (uintptr_t)NULL);

    while(true)
    {
        if(USB_I2C_GetCommand() == USB_I2C_CMD_WRITE)
        {
            memcpy(&USB_I2C_EEPROM_EmulationBuffer[emulated_EEPROM.wrAddr], &emulated_EEPROM.wrBuffer[0], emulated_EEPROM.nWrBytes);
            emulated_EEPROM.internalWriteInProgress = false;
            usbI2cCommand = USB_I2C_CMD_IDLE;
        }
    }
}

