/* Automatically generated nanopb constant definitions */
/* Generated by nanopb-0.3.9 at Thu Aug 15 14:04:23 2019. */

#include "acp.pb.h"

/* @@protoc_insertion_point(includes) */
#if PB_PROTO_HEADER_VERSION != 30
#error Regenerate this file with the current version of nanopb generator.
#endif



const pb_field_t acp_metric_datapoint_fields[6] = {
    PB_FIELD(  1, UENUM   , SINGULAR, STATIC  , FIRST, acp_metric_datapoint, data_type, data_type, 0),
    PB_FIELD(  2, STRING  , SINGULAR, STATIC  , OTHER, acp_metric_datapoint, name, data_type, 0),
    PB_FIELD(  6, UINT32  , SINGULAR, STATIC  , OTHER, acp_metric_datapoint, counter, name, 0),
    PB_FIELD(  8, STRING  , SINGULAR, CALLBACK, OTHER, acp_metric_datapoint, text, counter, 0),
    PB_FIELD(  9, FLOAT   , SINGULAR, STATIC  , OTHER, acp_metric_datapoint, number, text, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_time_fields[4] = {
    PB_FIELD(  1, INT32   , SINGULAR, STATIC  , FIRST, acp_time, hh, hh, 0),
    PB_FIELD(  2, INT32   , SINGULAR, STATIC  , OTHER, acp_time, mm, hh, 0),
    PB_FIELD(  3, INT32   , SINGULAR, STATIC  , OTHER, acp_time, ss, mm, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_property_fields[3] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, acp_property, name, name, 0),
    PB_FIELD(  2, STRING  , SINGULAR, STATIC  , OTHER, acp_property, value, name, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_fields[14] = {
    PB_ONEOF_FIELD(type,  12, MESSAGE , ONEOF, STATIC  , FIRST, acp_cmd, get_next_event_obj, get_next_event_obj, &acp_cmd_get_next_event_fields),
    PB_ONEOF_FIELD(type,  13, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, read_host_fw_update_bytes_obj, read_host_fw_update_bytes_obj, &acp_cmd_read_host_fw_update_bytes_fields),
    PB_ONEOF_FIELD(type,  14, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, get_firmware_version_obj, get_firmware_version_obj, &acp_cmd_get_firmware_version_fields),
    PB_ONEOF_FIELD(type,  15, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, trigger_factory_reset_obj, trigger_factory_reset_obj, &acp_cmd_trigger_factory_reset_fields),
    PB_ONEOF_FIELD(type,  16, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, enter_setup_mode_obj, enter_setup_mode_obj, &acp_cmd_enter_setup_mode_fields),
    PB_ONEOF_FIELD(type,  21, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, write_host_config_obj, write_host_config_obj, &acp_cmd_write_host_config_fields),
    PB_ONEOF_FIELD(type,  22, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, get_ack_hardware_info_obj, get_ack_hardware_info_obj, &acp_cmd_get_ack_hardware_info_fields),
    PB_ONEOF_FIELD(type,  23, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, get_ack_status_obj, get_ack_status_obj, &acp_cmd_get_ack_status_fields),
    PB_ONEOF_FIELD(type,  51, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, write_log_obj, write_log_obj, &acp_cmd_write_log_fields),
    PB_ONEOF_FIELD(type,  53, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, submit_logs_obj, submit_logs_obj, &acp_cmd_submit_logs_fields),
    PB_ONEOF_FIELD(type,  64, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, record_dem_metric_obj, record_dem_metric_obj, &acp_cmd_record_dem_metric_fields),
    PB_ONEOF_FIELD(type,  81, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, send_alexa_event_obj, send_alexa_event_obj, &acp_cmd_send_alexa_event_fields),
    PB_ONEOF_FIELD(type,  92, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd, provisioning_obj, provisioning_obj, &acp_cmd_provisioning_fields),
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_send_alexa_event_fields[2] = {
    PB_FIELD(  1, MESSAGE , SINGULAR, STATIC  , FIRST, acp_cmd_send_alexa_event, event, event, &V3AVS_AvsEvent_fields),
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_get_next_event_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_read_host_fw_update_bytes_fields[3] = {
    PB_FIELD(  1, UINT32  , SINGULAR, STATIC  , FIRST, acp_cmd_read_host_fw_update_bytes, offset, offset, 0),
    PB_FIELD(  2, UINT32  , SINGULAR, STATIC  , OTHER, acp_cmd_read_host_fw_update_bytes, length, offset, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_get_firmware_version_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_trigger_factory_reset_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_enter_setup_mode_fields[3] = {
    PB_FIELD(  1, UENUM   , SINGULAR, STATIC  , FIRST, acp_cmd_enter_setup_mode, mode, mode, 0),
    PB_FIELD(  2, UENUM   , SINGULAR, STATIC  , OTHER, acp_cmd_enter_setup_mode, security, mode, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_write_log_fields[4] = {
    PB_FIELD(  1, STRING  , SINGULAR, CALLBACK, FIRST, acp_cmd_write_log, component, component, 0),
    PB_FIELD(  2, UENUM   , SINGULAR, STATIC  , OTHER, acp_cmd_write_log, log_level, component, 0),
    PB_FIELD(  5, STRING  , SINGULAR, CALLBACK, OTHER, acp_cmd_write_log, message, log_level, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_submit_logs_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_record_dem_metric_fields[3] = {
    PB_FIELD(  1, UENUM   , SINGULAR, STATIC  , FIRST, acp_cmd_record_dem_metric, metric_type, metric_type, 0),
    PB_FIELD(  2, MESSAGE , REPEATED, CALLBACK, OTHER, acp_cmd_record_dem_metric, datapoints, metric_type, &acp_metric_datapoint_fields),
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_write_host_config_fields[3] = {
    PB_FIELD(  1, UINT64  , SINGULAR, STATIC  , FIRST, acp_cmd_write_host_config, firmware_version, firmware_version, 0),
    PB_FIELD(  4, MESSAGE , REPEATED, STATIC  , OTHER, acp_cmd_write_host_config, host_info, firmware_version, &acp_property_fields),
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_get_ack_hardware_info_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_get_ack_status_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_provisioning_fields[3] = {
    PB_ONEOF_FIELD(command,  10, MESSAGE , ONEOF, STATIC  , FIRST, acp_cmd_provisioning, get_provisioning_state_obj, get_provisioning_state_obj, &acp_cmd_provisioning_get_provisioning_state_fields),
    PB_ONEOF_FIELD(command,  11, MESSAGE , ONEOF, STATIC  , UNION, acp_cmd_provisioning, get_device_type_obj, get_device_type_obj, &acp_cmd_provisioning_get_device_type_fields),
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_provisioning_get_provisioning_state_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t acp_cmd_provisioning_get_device_type_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t acp_response_fields[13] = {
    PB_ONEOF_FIELD(type,   1, MESSAGE , ONEOF, STATIC  , FIRST, acp_response, generic_obj, generic_obj, &acp_response_generic_fields),
    PB_ONEOF_FIELD(type,   2, MESSAGE , ONEOF, STATIC  , UNION, acp_response, read_host_fw_update_bytes_obj, read_host_fw_update_bytes_obj, &acp_response_read_host_fw_update_bytes_fields),
    PB_ONEOF_FIELD(type,   3, MESSAGE , ONEOF, STATIC  , UNION, acp_response, get_firmware_version_obj, get_firmware_version_obj, &acp_response_get_firmware_version_fields),
    PB_ONEOF_FIELD(type,   5, MESSAGE , ONEOF, STATIC  , UNION, acp_response, get_ack_hardware_info_obj, get_ack_hardware_info_obj, &acp_response_get_ack_hardware_info_fields),
    PB_ONEOF_FIELD(type,   6, MESSAGE , ONEOF, STATIC  , UNION, acp_response, get_ack_status_obj, get_ack_status_obj, &acp_response_get_ack_status_fields),
    PB_ONEOF_FIELD(type,  41, MESSAGE , ONEOF, STATIC  , UNION, acp_response, reboot_requested_obj, reboot_requested_obj, &acp_event_reboot_requested_fields),
    PB_ONEOF_FIELD(type,  42, MESSAGE , ONEOF, STATIC  , UNION, acp_response, host_fw_update_received_obj, host_fw_update_received_obj, &acp_event_host_fw_update_received_fields),
    PB_ONEOF_FIELD(type,  43, MESSAGE , ONEOF, STATIC  , UNION, acp_response, log_level_changed_obj, log_level_changed_obj, &acp_event_log_level_changed_fields),
    PB_ONEOF_FIELD(type,  45, MESSAGE , ONEOF, STATIC  , UNION, acp_response, ack_booted_obj, ack_booted_obj, &acp_event_ack_booted_fields),
    PB_ONEOF_FIELD(type,  47, MESSAGE , ONEOF, STATIC  , UNION, acp_response, factory_reset_requested_obj, factory_reset_requested_obj, &acp_event_factory_reset_requested_fields),
    PB_ONEOF_FIELD(type,  61, MESSAGE , ONEOF, STATIC  , UNION, acp_response, alexa_directive_received_obj, alexa_directive_received_obj, &acp_event_alexa_directive_received_fields),
    PB_ONEOF_FIELD(type,  92, MESSAGE , ONEOF, STATIC  , UNION, acp_response, provisioning_obj, provisioning_obj, &acp_response_provisioning_fields),
    PB_LAST_FIELD
};

const pb_field_t acp_response_generic_fields[3] = {
    PB_FIELD(  1, UENUM   , SINGULAR, STATIC  , FIRST, acp_response_generic, code, code, 0),
    PB_FIELD(  2, STRING  , SINGULAR, CALLBACK, OTHER, acp_response_generic, description, code, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_response_read_host_fw_update_bytes_fields[2] = {
    PB_FIELD(  1, BYTES   , SINGULAR, CALLBACK, FIRST, acp_response_read_host_fw_update_bytes, bytes, bytes, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_response_get_firmware_version_fields[4] = {
    PB_FIELD(  3, UINT32  , SINGULAR, STATIC  , FIRST, acp_response_get_firmware_version, protocol_number, protocol_number, 0),
    PB_FIELD(  4, UINT32  , SINGULAR, STATIC  , OTHER, acp_response_get_firmware_version, build_number, protocol_number, 0),
    PB_FIELD(  5, STRING  , SINGULAR, CALLBACK, OTHER, acp_response_get_firmware_version, incremental_version, build_number, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_response_get_ack_hardware_info_fields[2] = {
    PB_FIELD(  1, STRING  , SINGULAR, CALLBACK, FIRST, acp_response_get_ack_hardware_info, dsn, dsn, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_response_get_ack_status_fields[8] = {
    PB_FIELD(  1, MESSAGE , SINGULAR, STATIC  , FIRST, acp_response_get_ack_status, current_time, current_time, &acp_time_fields),
    PB_FIELD(  2, UENUM   , SINGULAR, STATIC  , OTHER, acp_response_get_ack_status, wifi_mode, current_time, 0),
    PB_FIELD(  3, BOOL    , SINGULAR, STATIC  , OTHER, acp_response_get_ack_status, setup_mode, wifi_mode, 0),
    PB_FIELD(  4, UENUM   , SINGULAR, STATIC  , OTHER, acp_response_get_ack_status, error_code, setup_mode, 0),
    PB_FIELD(  5, UINT32  , SINGULAR, STATIC  , OTHER, acp_response_get_ack_status, setup_types, error_code, 0),
    PB_FIELD(  6, UENUM   , SINGULAR, STATIC  , OTHER, acp_response_get_ack_status, setup_stage, setup_types, 0),
    PB_FIELD(  7, UINT32  , SINGULAR, STATIC  , OTHER, acp_response_get_ack_status, epoch_seconds, setup_stage, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_response_provisioning_fields[3] = {
    PB_ONEOF_FIELD(response, 100, MESSAGE , ONEOF, STATIC  , FIRST, acp_response_provisioning, provisioning_info_obj, provisioning_info_obj, &acp_response_provisioning_provisioning_info_fields),
    PB_ONEOF_FIELD(response, 101, MESSAGE , ONEOF, STATIC  , UNION, acp_response_provisioning, device_type_obj, device_type_obj, &acp_response_provisioning_device_type_fields),
    PB_LAST_FIELD
};

const pb_field_t acp_response_provisioning_provisioning_info_fields[2] = {
    PB_FIELD( 10, UENUM   , SINGULAR, STATIC  , FIRST, acp_response_provisioning_provisioning_info, state, state, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_response_provisioning_device_type_fields[2] = {
    PB_FIELD( 11, STRING  , SINGULAR, CALLBACK, FIRST, acp_response_provisioning_device_type, device_type, device_type, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_event_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t acp_event_reboot_requested_fields[2] = {
    PB_FIELD(  1, BOOL    , SINGULAR, STATIC  , FIRST, acp_event_reboot_requested, force, force, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_event_host_fw_update_received_fields[5] = {
    PB_FIELD(  1, STRING  , SINGULAR, STATIC  , FIRST, acp_event_host_fw_update_received, version, version, 0),
    PB_FIELD(  2, UINT32  , SINGULAR, STATIC  , OTHER, acp_event_host_fw_update_received, size, version, 0),
    PB_FIELD(  3, STRING  , SINGULAR, STATIC  , OTHER, acp_event_host_fw_update_received, signature, size, 0),
    PB_FIELD(  4, BOOL    , SINGULAR, STATIC  , OTHER, acp_event_host_fw_update_received, force, signature, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_event_alexa_directive_received_fields[2] = {
    PB_FIELD(  1, MESSAGE , SINGULAR, STATIC  , FIRST, acp_event_alexa_directive_received, directive, directive, &V3AVS_AvsDirective_fields),
    PB_LAST_FIELD
};

const pb_field_t acp_event_log_level_changed_fields[2] = {
    PB_FIELD(  1, UENUM   , SINGULAR, STATIC  , FIRST, acp_event_log_level_changed, log_level, log_level, 0),
    PB_LAST_FIELD
};

const pb_field_t acp_event_ack_booted_fields[1] = {
    PB_LAST_FIELD
};

const pb_field_t acp_event_factory_reset_requested_fields[1] = {
    PB_LAST_FIELD
};














/* Check that field information fits in pb_field_t */
#if !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_32BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 * 
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in 8 or 16 bit
 * field descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(acp_cmd, type.get_next_event_obj) < 65536 && pb_membersize(acp_cmd, type.read_host_fw_update_bytes_obj) < 65536 && pb_membersize(acp_cmd, type.get_firmware_version_obj) < 65536 && pb_membersize(acp_cmd, type.trigger_factory_reset_obj) < 65536 && pb_membersize(acp_cmd, type.enter_setup_mode_obj) < 65536 && pb_membersize(acp_cmd, type.write_host_config_obj) < 65536 && pb_membersize(acp_cmd, type.get_ack_hardware_info_obj) < 65536 && pb_membersize(acp_cmd, type.get_ack_status_obj) < 65536 && pb_membersize(acp_cmd, type.write_log_obj) < 65536 && pb_membersize(acp_cmd, type.submit_logs_obj) < 65536 && pb_membersize(acp_cmd, type.record_dem_metric_obj) < 65536 && pb_membersize(acp_cmd, type.send_alexa_event_obj) < 65536 && pb_membersize(acp_cmd, type.provisioning_obj) < 65536 && pb_membersize(acp_cmd_send_alexa_event, event) < 65536 && pb_membersize(acp_cmd_write_host_config, host_info[0]) < 65536 && pb_membersize(acp_cmd_provisioning, command.get_provisioning_state_obj) < 65536 && pb_membersize(acp_cmd_provisioning, command.get_device_type_obj) < 65536 && pb_membersize(acp_response, type.generic_obj) < 65536 && pb_membersize(acp_response, type.read_host_fw_update_bytes_obj) < 65536 && pb_membersize(acp_response, type.get_firmware_version_obj) < 65536 && pb_membersize(acp_response, type.get_ack_hardware_info_obj) < 65536 && pb_membersize(acp_response, type.get_ack_status_obj) < 65536 && pb_membersize(acp_response, type.reboot_requested_obj) < 65536 && pb_membersize(acp_response, type.host_fw_update_received_obj) < 65536 && pb_membersize(acp_response, type.log_level_changed_obj) < 65536 && pb_membersize(acp_response, type.ack_booted_obj) < 65536 && pb_membersize(acp_response, type.factory_reset_requested_obj) < 65536 && pb_membersize(acp_response, type.alexa_directive_received_obj) < 65536 && pb_membersize(acp_response, type.provisioning_obj) < 65536 && pb_membersize(acp_response_get_ack_status, current_time) < 65536 && pb_membersize(acp_response_provisioning, response.provisioning_info_obj) < 65536 && pb_membersize(acp_response_provisioning, response.device_type_obj) < 65536 && pb_membersize(acp_event_alexa_directive_received, directive) < 65536), YOU_MUST_DEFINE_PB_FIELD_32BIT_FOR_MESSAGES_acp_metric_datapoint_acp_time_acp_property_acp_cmd_acp_cmd_send_alexa_event_acp_cmd_get_next_event_acp_cmd_read_host_fw_update_bytes_acp_cmd_get_firmware_version_acp_cmd_trigger_factory_reset_acp_cmd_enter_setup_mode_acp_cmd_write_log_acp_cmd_submit_logs_acp_cmd_record_dem_metric_acp_cmd_write_host_config_acp_cmd_get_ack_hardware_info_acp_cmd_get_ack_status_acp_cmd_provisioning_acp_cmd_provisioning_get_provisioning_state_acp_cmd_provisioning_get_device_type_acp_response_acp_response_generic_acp_response_read_host_fw_update_bytes_acp_response_get_firmware_version_acp_response_get_ack_hardware_info_acp_response_get_ack_status_acp_response_provisioning_acp_response_provisioning_provisioning_info_acp_response_provisioning_device_type_acp_event_acp_event_reboot_requested_acp_event_host_fw_update_received_acp_event_alexa_directive_received_acp_event_log_level_changed_acp_event_ack_booted_acp_event_factory_reset_requested)
#endif

#if !defined(PB_FIELD_16BIT) && !defined(PB_FIELD_32BIT)
/* If you get an error here, it means that you need to define PB_FIELD_16BIT
 * compile-time option. You can do that in pb.h or on compiler command line.
 * 
 * The reason you need to do this is that some of your messages contain tag
 * numbers or field sizes that are larger than what can fit in the default
 * 8 bit descriptors.
 */
PB_STATIC_ASSERT((pb_membersize(acp_cmd, type.get_next_event_obj) < 256 && pb_membersize(acp_cmd, type.read_host_fw_update_bytes_obj) < 256 && pb_membersize(acp_cmd, type.get_firmware_version_obj) < 256 && pb_membersize(acp_cmd, type.trigger_factory_reset_obj) < 256 && pb_membersize(acp_cmd, type.enter_setup_mode_obj) < 256 && pb_membersize(acp_cmd, type.write_host_config_obj) < 256 && pb_membersize(acp_cmd, type.get_ack_hardware_info_obj) < 256 && pb_membersize(acp_cmd, type.get_ack_status_obj) < 256 && pb_membersize(acp_cmd, type.write_log_obj) < 256 && pb_membersize(acp_cmd, type.submit_logs_obj) < 256 && pb_membersize(acp_cmd, type.record_dem_metric_obj) < 256 && pb_membersize(acp_cmd, type.send_alexa_event_obj) < 256 && pb_membersize(acp_cmd, type.provisioning_obj) < 256 && pb_membersize(acp_cmd_send_alexa_event, event) < 256 && pb_membersize(acp_cmd_write_host_config, host_info[0]) < 256 && pb_membersize(acp_cmd_provisioning, command.get_provisioning_state_obj) < 256 && pb_membersize(acp_cmd_provisioning, command.get_device_type_obj) < 256 && pb_membersize(acp_response, type.generic_obj) < 256 && pb_membersize(acp_response, type.read_host_fw_update_bytes_obj) < 256 && pb_membersize(acp_response, type.get_firmware_version_obj) < 256 && pb_membersize(acp_response, type.get_ack_hardware_info_obj) < 256 && pb_membersize(acp_response, type.get_ack_status_obj) < 256 && pb_membersize(acp_response, type.reboot_requested_obj) < 256 && pb_membersize(acp_response, type.host_fw_update_received_obj) < 256 && pb_membersize(acp_response, type.log_level_changed_obj) < 256 && pb_membersize(acp_response, type.ack_booted_obj) < 256 && pb_membersize(acp_response, type.factory_reset_requested_obj) < 256 && pb_membersize(acp_response, type.alexa_directive_received_obj) < 256 && pb_membersize(acp_response, type.provisioning_obj) < 256 && pb_membersize(acp_response_get_ack_status, current_time) < 256 && pb_membersize(acp_response_provisioning, response.provisioning_info_obj) < 256 && pb_membersize(acp_response_provisioning, response.device_type_obj) < 256 && pb_membersize(acp_event_alexa_directive_received, directive) < 256), YOU_MUST_DEFINE_PB_FIELD_16BIT_FOR_MESSAGES_acp_metric_datapoint_acp_time_acp_property_acp_cmd_acp_cmd_send_alexa_event_acp_cmd_get_next_event_acp_cmd_read_host_fw_update_bytes_acp_cmd_get_firmware_version_acp_cmd_trigger_factory_reset_acp_cmd_enter_setup_mode_acp_cmd_write_log_acp_cmd_submit_logs_acp_cmd_record_dem_metric_acp_cmd_write_host_config_acp_cmd_get_ack_hardware_info_acp_cmd_get_ack_status_acp_cmd_provisioning_acp_cmd_provisioning_get_provisioning_state_acp_cmd_provisioning_get_device_type_acp_response_acp_response_generic_acp_response_read_host_fw_update_bytes_acp_response_get_firmware_version_acp_response_get_ack_hardware_info_acp_response_get_ack_status_acp_response_provisioning_acp_response_provisioning_provisioning_info_acp_response_provisioning_device_type_acp_event_acp_event_reboot_requested_acp_event_host_fw_update_received_acp_event_alexa_directive_received_acp_event_log_level_changed_acp_event_ack_booted_acp_event_factory_reset_requested)
#endif


/* @@protoc_insertion_point(eof) */
