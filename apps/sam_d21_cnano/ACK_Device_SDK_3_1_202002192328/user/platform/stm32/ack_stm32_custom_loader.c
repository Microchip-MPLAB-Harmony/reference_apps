/*
 * Copyright 2018-2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * 
 * You may not use this file except in compliance with the terms and conditions set forth in the
 * accompanying LICENSE.TXT file. THESE MATERIALS ARE PROVIDED ON AN "AS IS" BASIS. AMAZON SPECIFICALLY
 * DISCLAIMS, WITH RESPECT TO THESE MATERIALS, ALL WARRANTIES, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.
 */

#include "main.h"
#include "ack_stm32_ota.h"
#include <stdbool.h>
#include <stdint.h>
#include "stm32f0xx_hal.h"
#include <string.h>

// We need to force this to the start of RAM (0x20000000). However the 'at' attribute wouldn't work if
// this is .bss/ZI/zero-initialized data because the linker script reserves that for initialized/RW data.
// We could alter the linker script to create our own section but it's easier to just
// force this to be initialized data and use the 'at' attribute.
uint32_t g_vectorTable[ACK_STM32_OTA_INTERRUPT_VECTOR_COUNT] __attribute__((at(SRAM_BASE))) = {1};

// Forward references.
static bool CheckStatusPartitionForUnappliedImage(void);
static bool ApplyOtaImage(void);
static bool EraseStatusPartitionToIndicateNoUnappliedImage(void);
static void UninitializeHardware(void);
static void MoveApplicationVectorsToRAM(void);
static void JumpToApplication(void);
static uint32_t CalculateCRC32(const void* pData, uint32_t dataSizeBytes);

// We inserted a line of code in the main() generated by STM32CubeMX, to call this routine.
// This routine does not return.
void Loader(void)
{
    // Check status partition to see whether there's an unapplied OTA image.
    if (CheckStatusPartitionForUnappliedImage())
    {
        if (ApplyOtaImage())
        {
            EraseStatusPartitionToIndicateNoUnappliedImage();
        }
    }

    // Now that we've applied an OTA image (or not) above, prepare to execute the application
    // on the Primary Partition.
    UninitializeHardware();
	MoveApplicationVectorsToRAM();

    // Does not return.
    JumpToApplication();
}

// Determines whether there's an unapplied OTA image in the Staging Partition.
bool CheckStatusPartitionForUnappliedImage(void)
{
    volatile ACKStm32OtaStatusPartition_t* pStatusPartition
        = (ACKStm32OtaStatusPartition_t*)ACK_STM32_OTA_STATUS_PARTITION_START;

    if ((pStatusPartition->Signature1 != ACK_STM32_OTA_STATUS_PARTITION_SIGNATURE1)
        || (pStatusPartition->Signature2 != ACK_STM32_OTA_STATUS_PARTITION_SIGNATURE2)
        || pStatusPartition->Pad[0]
        || pStatusPartition->Pad[1]
        || pStatusPartition->Pad[2]
        || (pStatusPartition->State != ACK_STM32_OTA_STATUS_PARTITION_STATE_UNAPPLIED_IMAGE)
        || (pStatusPartition->ImageSize == 0)
        || (pStatusPartition->ImageSize > ACK_STM32_OTA_STAGING_PARTITION_SIZE)
        || (pStatusPartition->ImageSize > ACK_STM32_OTA_PRIMARY_PARTITION_SIZE)
        || (pStatusPartition->ImageStartAddress != ACK_STM32_OTA_PRIMARY_PARTITION_START))
    {
        // Signature or pad bytes not valid, or they are valid and the state doesn't indicate
        // the presence of an unapplied OTA image. Or the image size is 0 or too large, or the
        // image is intended for a different address than where the Primary Partition is.
        return false;
    }

    // Check CRC32 of data bytes.
    uint32_t crc = CalculateCRC32(
        (const void*)ACK_STM32_OTA_STAGING_PARTITION_START,
        pStatusPartition->ImageSize);
    if (crc != pStatusPartition->Crc32)
    {
        return false;
    }

    return true;
}

// Programs flash representing the Primary Partition with the contents of the Staging Partition.
bool ApplyOtaImage(void)
{
    unsigned status;
    uint32_t errorAddress;
    volatile ACKStm32OtaStatusPartition_t* pStatusPartition 
        = (ACKStm32OtaStatusPartition_t*)ACK_STM32_OTA_STATUS_PARTITION_START;

    uint32_t _16BitWordCount = pStatusPartition->ImageSize / 2;
    if (pStatusPartition->ImageSize & 1)
    {
        ++_16BitWordCount;
    }

    ACKStm32Ota_FlashBegin();

#if (ACK_STM32_OTA_PRIMARY_PARTITION_START % ACK_STM32_OTA_FLASH_PAGE_SIZE)
#error Staging Partition must be an even multiple of the flash page size.
#endif
    status = ACKStm32Ota_FlashErase(
        ACK_STM32_OTA_PRIMARY_PARTITION_START / ACK_STM32_OTA_FLASH_PAGE_SIZE,
        _16BitWordCount * 2,
        &errorAddress);
    if (0 == status)
    {
        status = ACKStm32Ota_FlashWrite(
            ACK_STM32_OTA_PRIMARY_PARTITION_START,
            (const void*)ACK_STM32_OTA_STAGING_PARTITION_START,
            _16BitWordCount,
            &errorAddress);
    }

    ACKStm32Ota_FlashEnd();

    return 0 == status;
}

bool EraseStatusPartitionToIndicateNoUnappliedImage(void)
{
    unsigned status;
    uint32_t errorAddress;

    ACKStm32Ota_FlashBegin();

#if (ACK_STM32_OTA_STAGING_PARTITION_START % ACK_STM32_OTA_FLASH_PAGE_SIZE)
#error Staging Partition must be an even multiple of the flash page size.
#endif
    status = ACKStm32Ota_FlashErase(
        ACK_STM32_OTA_STATUS_PARTITION_START / ACK_STM32_OTA_FLASH_PAGE_SIZE,
        ACK_STM32_OTA_STATUS_PARTITION_SIZE,
        &errorAddress);

    ACKStm32Ota_FlashEnd();

    return 0 == status;
}

// STM32CubeMX generates initalization routines but it doesn't generate routines to
// deinit/reinitialize the hardware.
void UninitializeHardware(void)
{
    // This is the inverse of the generated MX_CRC_Init routine.
    extern CRC_HandleTypeDef hcrc;
    HAL_CRC_DeInit(&hcrc);

// The STM32F030xC project has no hardware defined, so this section doesn't apply.
#ifdef STM32F030x8
    // This must be the exact inverse of the generated MX_GPIO_Init routine.
    HAL_GPIO_DeInit(B1_GPIO_Port, B1_Pin);
    HAL_GPIO_DeInit(LD2_GPIO_Port, LD2_Pin);
#endif
    
    __HAL_RCC_GPIOC_CLK_DISABLE();
    __HAL_RCC_GPIOA_CLK_DISABLE();

    // Reset clocks to default state. Essentially the inverse of SystemInit().
    HAL_RCC_DeInit();
    
    // Reset peripherals to default power-on state.
    HAL_DeInit();
    
    // Reset SysTick state.
    // http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0497a/Bhccjgga.html.
    SysTick->CTRL = 0;
    SysTick->VAL = 0;
    SysTick->LOAD = 0;
}

// Moves application vectors to RAM.
// NOTE: The application MUST be programmed to start RAM at 200000b4 (not 20000000),
// or else upon startup the CRT will initialize 20000000, clobbering the vector table
// we will copy into RAM at 20000000.
void MoveApplicationVectorsToRAM(void)
{
	int wasMasked = __disable_irq();

	memcpy(g_vectorTable, (void*)ACK_STM32_OTA_PRIMARY_PARTITION_START, sizeof(g_vectorTable));
	
	__HAL_SYSCFG_REMAPMEMORY_SRAM();
	
    if (!wasMasked)
    {
        __enable_irq();
    }
}

void JumpToApplication(void)
{
    // Set up stack and program counter. Does not return.
    // On ARM it's OK for us to model jumping to the application as a function call,
    // because this ends up being a BL instruction. The BL instruction does not
    // use the stack (it puts its return address in a register).
    __set_MSP(*(volatile uint32_t*)ACK_STM32_OTA_PRIMARY_PARTITION_START);
    ((void(*)(void))(((volatile uint32_t*)ACK_STM32_OTA_PRIMARY_PARTITION_START)[1]))();
    
    // Never get here.
}

uint32_t CalculateCRC32(const void* pData, uint32_t dataSizeBytes)
{
    extern CRC_HandleTypeDef hcrc;

    HAL_CRCEx_Input_Data_Reverse(&hcrc, CRC_INPUTDATA_INVERSION_BYTE);
    HAL_CRCEx_Output_Data_Reverse(&hcrc, CRC_OUTPUTDATA_INVERSION_ENABLE);

    return HAL_CRC_Calculate(&hcrc, (uint32_t*)pData, dataSizeBytes) ^ 0xffffffff;
}
